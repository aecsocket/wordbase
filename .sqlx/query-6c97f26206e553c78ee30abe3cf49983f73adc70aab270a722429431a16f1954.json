{
  "db_name": "SQLite",
  "query": "SELECT\n                record.id,\n                record.source,\n                record.kind,\n                record.data,\n                term_record.headword,\n                term_record.reading,\n                profile_frequency.mode AS 'profile_frequency_mode?',\n                profile_frequency.value AS 'profile_frequency_value?',\n                source_frequency.mode AS 'source_frequency_mode?',\n                source_frequency.value AS 'source_frequency_value?'\n            FROM record\n            INNER JOIN dictionary ON record.source = dictionary.id\n\n            -- make sure the dictionary we're getting this record from is enabled\n            INNER JOIN profile_enabled_dictionary ped\n                ON (ped.profile = $1 AND ped.dictionary = dictionary.id)\n\n            -- find which terms reference this record, either through the headword or reading\n            INNER JOIN term_record ON (\n                term_record.record = record.id\n                AND (term_record.headword = $2 OR term_record.reading = $2)\n            )\n\n            -- join on profile-global frequency information, for the `ORDER BY` below\n            LEFT JOIN frequency profile_frequency ON (\n                -- only use frequency info from the currently selected sorting dict in this profile\n                profile_frequency.source = (\n                    SELECT sorting_dictionary FROM profile\n                    WHERE id = $1\n                )\n                AND profile_frequency.headword = term_record.headword\n                AND profile_frequency.reading = term_record.reading\n            )\n\n            -- join on frequency information for this source\n            LEFT JOIN frequency source_frequency ON (\n                source_frequency.source = record.source\n                AND source_frequency.headword = term_record.headword\n                AND source_frequency.reading = term_record.reading\n            )\n\n            -- only include records for the given record kinds\n            WHERE kind IN (SELECT value FROM json_each($3))\n\n            ORDER BY\n                CASE\n                    -- prioritize results where both the headword and reading match the lemma\n                    -- e.g. if you typed あらゆる:\n                    -- - the first results would be for the kana あらゆる\n                    -- - then the kanji like 汎ゆる\n                    WHEN term_record.reading = $2 AND term_record.headword = $2 THEN 0\n                    -- then prioritize results where at least the reading or headword are an exact match\n                    -- e.g. in 念じる, usually 念ずる comes up first\n                    -- but this is obviously a different reading\n                    -- so we want to prioritize 念じる\n                    WHEN term_record.reading = $2 OR term_record.headword = $2 THEN 1\n                    -- all other results at the end\n                    ELSE 2\n                END,\n                -- user-specified dictionary sorting position always takes priority\n                dictionary.position,\n                -- put entries without an explicit frequency value last\n                CASE\n                    WHEN profile_frequency.mode IS NULL THEN 1\n                    ELSE 0\n                END,\n                -- sort by profile-global frequency info\n                CASE\n                    -- frequency rank\n                    WHEN profile_frequency.mode = 0 THEN  profile_frequency.value\n                    -- frequency occurrence\n                    WHEN profile_frequency.mode = 1 THEN -profile_frequency.value\n                    ELSE 0\n                END,\n                -- sort by source-specific frequency info\n                CASE\n                    WHEN source_frequency.mode = 0 THEN  source_frequency.value\n                    WHEN source_frequency.mode = 1 THEN -source_frequency.value\n                    ELSE 0\n                END",
  "describe": {
    "columns": [
      {
        "name": "id",
        "ordinal": 0,
        "type_info": "Integer"
      },
      {
        "name": "source",
        "ordinal": 1,
        "type_info": "Integer"
      },
      {
        "name": "kind",
        "ordinal": 2,
        "type_info": "Integer"
      },
      {
        "name": "data",
        "ordinal": 3,
        "type_info": "Blob"
      },
      {
        "name": "headword",
        "ordinal": 4,
        "type_info": "Text"
      },
      {
        "name": "reading",
        "ordinal": 5,
        "type_info": "Text"
      },
      {
        "name": "profile_frequency_mode?",
        "ordinal": 6,
        "type_info": "Integer"
      },
      {
        "name": "profile_frequency_value?",
        "ordinal": 7,
        "type_info": "Integer"
      },
      {
        "name": "source_frequency_mode?",
        "ordinal": 8,
        "type_info": "Integer"
      },
      {
        "name": "source_frequency_value?",
        "ordinal": 9,
        "type_info": "Integer"
      }
    ],
    "parameters": {
      "Right": 3
    },
    "nullable": [
      false,
      false,
      false,
      false,
      true,
      true,
      false,
      false,
      false,
      false
    ]
  },
  "hash": "6c97f26206e553c78ee30abe3cf49983f73adc70aab270a722429431a16f1954"
}
